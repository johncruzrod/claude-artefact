import React, { useState, useEffect, useRef } from 'react';

const DoublePendulum = () => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const [graphData, setGraphData] = useState([]);

  // Simulation parameters
  const [initialAngle1, setInitialAngle1] = useState(Math.PI / 2);
  const [initialAngle2, setInitialAngle2] = useState(Math.PI / 2);
  const [length1, setLength1] = useState(80);
  const [length2, setLength2] = useState(80);
  const [mass1, setMass1] = useState(10);
  const [mass2, setMass2] = useState(10);
  const [gravity, setGravity] = useState(9.81);
  const [damping, setDamping] = useState(0.999);
  const [zoom, setZoom] = useState(1); // Zoom parameter

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    // Angles and velocities
    let angle1 = initialAngle1;
    let angle2 = initialAngle2;
    let angle1Velocity = 0;
    let angle2Velocity = 0;
    let time = 0;

    // Trails
    let blueTrail = [];
    let redTrail = [];

    // Clear any existing graph data
    setGraphData([]);

    const animate = () => {
      // White background
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const dt = 0.05;

      // Physics calculations
      const num1 = -gravity * (2 * mass1 + mass2) * Math.sin(angle1);
      const num2 = -mass2 * gravity * Math.sin(angle1 - 2 * angle2);
      const num3 = -2 * Math.sin(angle1 - angle2) * mass2;
      const num4 = angle2Velocity * angle2Velocity * length2
        + angle1Velocity * angle1Velocity * length1 * Math.cos(angle1 - angle2);
      const den = length1 * (2 * mass1 + mass2 - mass2 * Math.cos(2 * angle1 - 2 * angle2));
      const angle1Acceleration = (num1 + num2 + num3 * num4) / den;

      const num5 = 2 * Math.sin(angle1 - angle2);
      const num6 = angle1Velocity * angle1Velocity * length1 * (mass1 + mass2);
      const num7 = gravity * (mass1 + mass2) * Math.cos(angle1);
      const num8 = angle2Velocity * angle2Velocity * length2 * mass2 * Math.cos(angle1 - angle2);
      const den2 = length2 * (2 * mass1 + mass2 - mass2 * Math.cos(2 * angle1 - 2 * angle2));
      const angle2Acceleration = (num5 * (num6 + num7 + num8)) / den2;

      // Update velocities and angles
      angle1Velocity += angle1Acceleration * dt;
      angle2Velocity += angle2Acceleration * dt;
      angle1 += angle1Velocity * dt;
      angle2 += angle2Velocity * dt;

      // Damping
      angle1Velocity *= damping;
      angle2Velocity *= damping;

      // Calculate positions with zoom factor
      const pivotX = canvas.width / 2;
      const pivotY = canvas.height / 3;
      const x1 = pivotX + (length1 * zoom) * Math.sin(angle1);
      const y1 = pivotY + (length1 * zoom) * Math.cos(angle1);
      const x2 = x1 + (length2 * zoom) * Math.sin(angle2);
      const y2 = y1 + (length2 * zoom) * Math.cos(angle2);

      // Draw pivot and arms
      ctx.beginPath();
      ctx.arc(pivotX, pivotY, 5, 0, 2 * Math.PI);
      ctx.fillStyle = 'black';
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(pivotX, pivotY);
      ctx.lineTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Update trails
      blueTrail.push({ x: x1, y: y1 });
      redTrail.push({ x: x2, y: y2 });
      if (blueTrail.length > 200) blueTrail.shift();
      if (redTrail.length > 200) redTrail.shift();

      // Draw trails in the colour of the corresponding mass
      const drawTrail = (trail, color) => {
        ctx.beginPath();
        trail.forEach((point, index) => {
          ctx.lineTo(point.x, point.y);
          // Fade out older parts of the trail
          ctx.strokeStyle = `rgba(${color}, ${index / trail.length})`;
          ctx.stroke();
        });
      };

      drawTrail(blueTrail, '0, 0, 255');
      drawTrail(redTrail, '255, 0, 0');

      // Draw pendulum masses
      ctx.beginPath();
      ctx.arc(x1, y1, 10, 0, 2 * Math.PI);
      ctx.fillStyle = 'blue';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x2, y2, 10, 0, 2 * Math.PI);
      ctx.fillStyle = 'red';
      ctx.fill();

      // Increment time (though not used in chart anymore, we keep it if needed)
      time += dt;

      animationRef.current = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [
    initialAngle1,
    initialAngle2,
    length1,
    length2,
    mass1,
    mass2,
    gravity,
    damping,
    zoom
  ]);

  return (
    <div className="flex">
      {/* Controls Panel (Left) */}
      <div className="w-64 p-4 bg-gray-100 rounded-lg flex-shrink-0">
        <h2 className="text-lg font-bold text-gray-800 mb-4">Simulation Controls</h2>
        
        <div className="mb-4">
          <label htmlFor="angle1-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Initial Angle 1: {initialAngle1.toFixed(2)} rad
          </label>
          <input
            id="angle1-slider"
            type="range"
            min={0}
            max={Math.PI * 2}
            step={0.01}
            value={initialAngle1}
            onChange={(e) => setInitialAngle1(parseFloat(e.target.value))}
            className="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="angle2-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Initial Angle 2: {initialAngle2.toFixed(2)} rad
          </label>
          <input
            id="angle2-slider"
            type="range"
            min={0}
            max={Math.PI * 2}
            step={0.01}
            value={initialAngle2}
            onChange={(e) => setInitialAngle2(parseFloat(e.target.value))}
            className="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="length1-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Length 1: {length1}px
          </label>
          <input
            id="length1-slider"
            type="range"
            min={20}
            max={200}
            step={1}
            value={length1}
            onChange={(e) => setLength1(parseFloat(e.target.value))}
            className="w-full h-2 bg-green-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="length2-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Length 2: {length2}px
          </label>
          <input
            id="length2-slider"
            type="range"
            min={20}
            max={200}
            step={1}
            value={length2}
            onChange={(e) => setLength2(parseFloat(e.target.value))}
            className="w-full h-2 bg-green-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="mass1-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Mass 1: {mass1} kg
          </label>
          <input
            id="mass1-slider"
            type="range"
            min={1}
            max={50}
            step={1}
            value={mass1}
            onChange={(e) => setMass1(parseFloat(e.target.value))}
            className="w-full h-2 bg-red-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="mass2-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Mass 2: {mass2} kg
          </label>
          <input
            id="mass2-slider"
            type="range"
            min={1}
            max={50}
            step={1}
            value={mass2}
            onChange={(e) => setMass2(parseFloat(e.target.value))}
            className="w-full h-2 bg-red-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="gravity-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Gravity: {gravity.toFixed(2)} m/sÂ²
          </label>
          <input
            id="gravity-slider"
            type="range"
            min={0}
            max={20}
            step={0.1}
            value={gravity}
            onChange={(e) => setGravity(parseFloat(e.target.value))}
            className="w-full h-2 bg-yellow-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="damping-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Damping: {damping.toFixed(3)}
          </label>
          <input
            id="damping-slider"
            type="range"
            min={0.95}
            max={1}
            step={0.001}
            value={damping}
            onChange={(e) => setDamping(parseFloat(e.target.value))}
            className="w-full h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="zoom-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Zoom: {zoom.toFixed(2)}
          </label>
          <input
            id="zoom-slider"
            type="range"
            min={0.1}
            max={2}
            step={0.01}
            value={zoom}
            onChange={(e) => setZoom(parseFloat(e.target.value))}
            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
      </div>

      {/* Pendulum View (Right) */}
      <div className="flex flex-col items-center p-4">
        <canvas
          ref={canvasRef}
          width={600}
          height={600}
          className="border border-gray-300 rounded"
        />
      </div>
    </div>
  );
};

export default DoublePendulum;
