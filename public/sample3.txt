import React, { useState, useEffect, useRef } from 'react';

// Up to 5 different colours for 5 masses
const MASS_COLOURS = ['red', 'blue', 'green', 'orange', 'purple'];

/**
 * This component implements a simple chain of up to 5 pendulums,
 * each treated as a point mass connected by a rigid rod to the previous pivot.
 * We apply gravity and then enforce each rod's distance constraint.
 * Crucially, we also project out the radial component of velocity to allow
 * tangential swinging. This prevents the masses from just locking in place.
 */
const MultiPendulum = () => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);

  // Number of pendulum masses (1 to 5)
  const [numMasses, setNumMasses] = useState(3);

  // Arrays for the rod lengths, masses and initial angles (from the vertical)
  const [lengths, setLengths] = useState([80, 80, 80, 80, 80]);
  const [masses, setMasses] = useState([10, 10, 10, 10, 10]);
  const [angles, setAngles] = useState([
    Math.PI / 2,
    Math.PI / 2,
    Math.PI / 2,
    Math.PI / 2,
    Math.PI / 2
  ]);

  // Other global parameters
  const [gravity, setGravity] = useState(9.81);
  const [damping, setDamping] = useState(0.999);
  const [zoom, setZoom] = useState(1);

  // Internal arrays for positions, velocities and trails
  // We will reinitialise them whenever the user changes the setup
  let positions = [];
  let velocities = [];
  let trails = [];

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    // Create arrays to store positions, velocities and trails for each mass
    positions = Array(numMasses)
      .fill(null)
      .map(() => ({ x: 0, y: 0 }));
    velocities = Array(numMasses)
      .fill(null)
      .map(() => ({ x: 0, y: 0 }));
    trails = Array(numMasses)
      .fill(null)
      .map(() => []);

    // Set up initial positions from angles
    // Each mass i is offset from the previous pivot by length[i], at angles[i] from vertical
    const pivotX = canvas.width / 2;
    const pivotY = canvas.height / 3;

    for (let i = 0; i < numMasses; i++) {
      if (i === 0) {
        // First mass is directly from the fixed pivot
        positions[i].x = pivotX + (lengths[i] * zoom) * Math.sin(angles[i]);
        positions[i].y = pivotY + (lengths[i] * zoom) * Math.cos(angles[i]);
      } else {
        // Subsequent masses offset from the previous mass
        positions[i].x =
          positions[i - 1].x + (lengths[i] * zoom) * Math.sin(angles[i]);
        positions[i].y =
          positions[i - 1].y + (lengths[i] * zoom) * Math.cos(angles[i]);
      }
      // Zero initial velocity by default
      velocities[i].x = 0;
      velocities[i].y = 0;
      // Empty trail
      trails[i] = [];
    }

    const dt = 0.05;
    const animate = () => {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 1. Apply gravity to each mass
      for (let i = 0; i < numMasses; i++) {
        velocities[i].y += gravity * dt; // downward acceleration
      }

      // 2. Integrate positions
      for (let i = 0; i < numMasses; i++) {
        positions[i].x += velocities[i].x * dt;
        positions[i].y += velocities[i].y * dt;
      }

      // 3. Enforce rod constraints and project out radial velocity
      for (let i = 0; i < numMasses; i++) {
        // Determine the pivot for mass i
        let pivotPos;
        if (i === 0) {
          pivotPos = { x: pivotX, y: pivotY };
        } else {
          pivotPos = positions[i - 1];
        }

        // Current dx, dy
        const dx = positions[i].x - pivotPos.x;
        const dy = positions[i].y - pivotPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const desired = lengths[i] * zoom;

        // Position correction (keep rod length constant)
        if (dist !== 0) {
          const diff = (dist - desired) / dist;
          positions[i].x -= dx * diff;
          positions[i].y -= dy * diff;
        }

        // Velocity correction (remove radial component)
        // so the mass can only move tangentially along the circle
        const nx = positions[i].x - pivotPos.x;
        const ny = positions[i].y - pivotPos.y;
        const nDist = Math.sqrt(nx * nx + ny * ny);
        if (nDist > 1e-8) {
          // Normalised rod direction
          const invDist = 1 / nDist;
          const rodX = nx * invDist;
          const rodY = ny * invDist;

          // Dot product of velocity with rod direction
          const dot = velocities[i].x * rodX + velocities[i].y * rodY;
          // Subtract out the radial component
          velocities[i].x -= dot * rodX;
          velocities[i].y -= dot * rodY;
        }
      }

      // 4. Apply damping to velocities
      for (let i = 0; i < numMasses; i++) {
        velocities[i].x *= damping;
        velocities[i].y *= damping;
      }

      // 5. Draw everything
      // Draw the fixed pivot
      ctx.beginPath();
      ctx.arc(pivotX, pivotY, 5, 0, 2 * Math.PI);
      ctx.fillStyle = 'black';
      ctx.fill();

      // For each mass, draw rod, trail and mass
      for (let i = 0; i < numMasses; i++) {
        // Pivot for rod i
        let pivotPos;
        if (i === 0) {
          pivotPos = { x: pivotX, y: pivotY };
        } else {
          pivotPos = positions[i - 1];
        }

        // Draw rod
        ctx.beginPath();
        ctx.moveTo(pivotPos.x, pivotPos.y);
        ctx.lineTo(positions[i].x, positions[i].y);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Update trail
        trails[i].push({ x: positions[i].x, y: positions[i].y });
        if (trails[i].length > 200) {
          trails[i].shift();
        }

        // Draw trail
        ctx.beginPath();
        for (let j = 0; j < trails[i].length; j++) {
          ctx.lineTo(trails[i][j].x, trails[i][j].y);
          ctx.strokeStyle = `rgba(${getRgbForIndex(i)}, ${j / trails[i].length})`;
          ctx.stroke();
        }

        // Draw mass
        ctx.beginPath();
        ctx.arc(positions[i].x, positions[i].y, 10, 0, 2 * Math.PI);
        ctx.fillStyle = MASS_COLOURS[i];
        ctx.fill();
      }

      animationRef.current = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [
    numMasses,
    lengths,
    masses, // Masses not strictly used in this simple constraint approach, but included for extension
    angles,
    gravity,
    damping,
    zoom
  ]);

  // Convert named colours to RGB for trail drawing
  const getRgbForIndex = (i) => {
    switch (MASS_COLOURS[i]) {
      case 'red':
        return '255, 0, 0';
      case 'blue':
        return '0, 0, 255';
      case 'green':
        return '0, 128, 0';
      case 'orange':
        return '255, 165, 0';
      case 'purple':
        return '128, 0, 128';
      default:
        return '0, 0, 0';
    }
  };

  // Handlers for updating array values
  const handleNumMassesChange = (e) => {
    setNumMasses(parseInt(e.target.value));
  };

  const handleLengthChange = (index, value) => {
    const newLengths = [...lengths];
    newLengths[index] = parseFloat(value);
    setLengths(newLengths);
  };

  const handleMassChange = (index, value) => {
    const newMasses = [...masses];
    newMasses[index] = parseFloat(value);
    setMasses(newMasses);
  };

  const handleAngleChange = (index, value) => {
    const newAngles = [...angles];
    newAngles[index] = parseFloat(value);
    setAngles(newAngles);
  };

  return (
    <div className="flex">
      {/* Controls Panel (Left) */}
      <div className="w-64 p-4 bg-gray-100 rounded-lg flex-shrink-0">
        <h2 className="text-lg font-bold text-gray-800 mb-4">Simulation Controls</h2>

        {/* Number of Masses */}
        <div className="mb-4">
          <label htmlFor="numMasses" className="block text-sm font-medium text-gray-700 mb-1">
            Number of Masses: {numMasses}
          </label>
          <input
            id="numMasses"
            type="range"
            min={1}
            max={5}
            step={1}
            value={numMasses}
            onChange={handleNumMassesChange}
            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>

        {/* Sliders for each mass, shown only if i < numMasses */}
        {Array.from({ length: 5 }).map((_, i) => {
          if (i >= numMasses) return null;
          return (
            <div key={i} className="mb-4 border border-gray-200 p-2 rounded">
              <p className="font-semibold text-sm text-gray-600">
                Mass {i + 1} ({MASS_COLOURS[i]})
              </p>

              <label className="block text-xs text-gray-700 mt-2">
                Initial Angle: {angles[i].toFixed(2)} rad
              </label>
              <input
                type="range"
                min={0}
                max={Math.PI * 2}
                step={0.01}
                value={angles[i]}
                onChange={(e) => handleAngleChange(i, e.target.value)}
                className="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
              />

              <label className="block text-xs text-gray-700 mt-2">
                Length: {lengths[i]}px
              </label>
              <input
                type="range"
                min={20}
                max={200}
                step={1}
                value={lengths[i]}
                onChange={(e) => handleLengthChange(i, e.target.value)}
                className="w-full h-2 bg-green-200 rounded-lg appearance-none cursor-pointer"
              />

              <label className="block text-xs text-gray-700 mt-2">
                Mass: {masses[i]} kg
              </label>
              <input
                type="range"
                min={1}
                max={50}
                step={1}
                value={masses[i]}
                onChange={(e) => handleMassChange(i, e.target.value)}
                className="w-full h-2 bg-red-200 rounded-lg appearance-none cursor-pointer"
              />
            </div>
          );
        })}

        {/* Global sliders */}
        <div className="mb-4">
          <label htmlFor="gravity-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Gravity: {gravity.toFixed(2)} m/sÂ²
          </label>
          <input
            id="gravity-slider"
            type="range"
            min={0}
            max={20}
            step={0.1}
            value={gravity}
            onChange={(e) => setGravity(parseFloat(e.target.value))}
            className="w-full h-2 bg-yellow-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>

        <div className="mb-4">
          <label htmlFor="damping-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Damping: {damping.toFixed(3)}
          </label>
          <input
            id="damping-slider"
            type="range"
            min={0.95}
            max={1}
            step={0.001}
            value={damping}
            onChange={(e) => setDamping(parseFloat(e.target.value))}
            className="w-full h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>

        <div className="mb-4">
          <label htmlFor="zoom-slider" className="block text-sm font-medium text-gray-700 mb-1">
            Zoom: {zoom.toFixed(2)}
          </label>
          <input
            id="zoom-slider"
            type="range"
            min={0.1}
            max={2}
            step={0.01}
            value={zoom}
            onChange={(e) => setZoom(parseFloat(e.target.value))}
            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
      </div>

      {/* Pendulum View (Right) */}
      <div className="flex flex-col items-center p-4">
        <canvas
          ref={canvasRef}
          width={600}
          height={600}
          className="border border-gray-300 rounded"
        />
      </div>
    </div>
  );
};

export default MultiPendulum;
